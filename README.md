## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2401`

#### Выполнил: `Тараканов Владислав Алексеевич`

#### Вариант: `27`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Математическая модель](#3-математическая-модель)
- [Выбор структуры данных](#4-выбор-структуры-данных)
- [Алгоритм](#5-алгоритм)
- [Программа](#6-программа)
- [Анализ правильности решения](#7-анализ-правильности-решения)

### 1. Постановка задачи

На вход программе с консоли даются размеры массива N и M, затем элементы
массива размером N × M.
1. Отсортировать столбцы массива по возрастанию среднего арифметического значения в столбце. Если средние значения равны, отсортировать
    по возрастанию дисперсии элементов в столбце.
2. Найти и вывести медиану всех элементов массива.
4. Вывести гистограмму распределения элементов массива, разбивая
   диапазон значений на интервалы.
5. Нормализовать элементы массива (привести к диапазону от 0 до 1)
   и вывести полученный массив.


Данную задачу можно разделить подзадачи:
1.  Введем размеры и элементы массива.
2.  Создадим дополнительный двумерный массив, куда запишем номер столбца, значение
     среднего арифметического и дисперсии в нем.
3.  Затем отсортируем дополнительный массив по условию задачи 1.
4.  На основе дополнительного массива отсортируем исходный.
5.  Создадим дополнительный массив 2 и заполним его всеми элементами исходного массива.
6.  Отсортируем дополнительный массив 2 по возрастанию.
7.  В зависимости от количетсва элементов в исходном массиве выведем медиану всех элементов массива.
8.  Зададим нижнюю и верхнюю границу общего интервала значений элементов в исходном массиве.
9.  Подсчитаем сколько элементов исходного массива находится в каждом интервале и выведем данные для гистограммы.
10. Зададим нормализующий элемент в зависимости от максимального элемента исходного массива и приведем отсортированный
     исходный массив к интервалу от 0 до 1 и выведем его.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа получает сначала два натуральных числа, т.к. числа, указывающие размер массива
не могут быть отрицательными и не целыми числами. А потом вводятся элементы массива, мы знаем, что они дробные.
|        | Тип              | min значение    | max значение     |
|--------|------------------|-----------------|------------------|
|    N   | Натуральное число| 1               | 2<sup>31</sup>-1 |
|    M   | Натуральное число| 1               | 2<sup>31</sup>-1 |
| a[i][j]| Дробное число    | 1.7е-308        | 1.7е+308         |

#### Данные на выход

Программа должна вывести медиану всех элементов массива, она может быть дробным числом. 
Также нужно вывести массив с значениями для гистограммы и нормализовавнный массив.

|               | Тип    | 
|---------------|--------|
| Дробное число | Double | 
| Массив        | Int    | 
| Массив        | Double | 

### 3. Математическая модель


1. Среднее арифметическое чисел
   Среднее арифметическое = $`\frac{(x_1 + x_2 + ... + x_n)}{n}`$, где $`x_i`$- элемент последовательности, а n- количество элементов последовательности
2. Дисперсия
   Дисперсия = $`\frac{(y_1^2 + y_2^2 + ... + y_n^2)}{n}`$, где $`y_i`$ = среднее арифметическое последовательности - $`x_i`$, а n - количество элементов последовательности

### 4. Выбор структуры данных

Программа получает два натуральных числа. Поэтому для его хранения
можно выделить две переменные (`N` и `M`) типа `int`. Также на вход 
даются дробные числа для заполнения массива. Для них создаем массив(`a`)  типа `double`.
Для выполнения программы также используются вспомогательные массивы и переменные для хранения
крайних значенийй интервалов(`N` и `M`), значения индекса в массиве(`ind`) типа `int`, 
суммы элементов в столбце(`sum`) типа `double`, перестановки элементов в массиве(`temp`) типа `int`,
значения дисперсии столбца(`disp`) типа `double` и значения индекса нормализации(`norm`) типа `double`. 
В массивах же хранятся отсортированные по возростанию среднего арифметического или дисперсии элементы 
исходного массива(`sorted`) типа `double`, данные для нахождения медианы элементов(`med`) типа `double`, 
данные для построения гистрограммы(`gist`) типа `int` и значений среднего арифметического и дисперсии в каждом столбце(`sr`) типа `double`.

|       | название переменной | Тип (в Java) | 
|-------|---------------------|--------------|
| Число | `N`                 | `int`        |
| Число | `M`                 | `int`        |
| Число | `ind`               | `int`        |
| Число | `sum`               | `double`     |
| Число | `min1`              | `double`     |
| Число | `max1`              | `double`     |
| Число | `min`               | `int`        |
| Число | `max`               | `int`        |
| Число | `norm`              | `int`        |
| Число | `temp`              | `int`        |
| Число | `disp`              | `int`        |
| Массив| `a`                 | `double`     |
| Массив| `gist`              | `int`        |
| Массив| `sorted`            | `double`     |
| Массив| `med`               | `double`     |
| Массив| `sr`                | `double`     |


### 5. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два натуральных числа, обозначенных как `N` и `M`.
   Затем считывает элементы массива `a`.

2. **Нахождение среднего арифметического и дисперсии столбца, а затем сортировка по возрастанию среднего арифметического и десперсии:**  
   Программа считает сумму цифр в столбце и делит её на `N`, затем записывает эти значения в массив `sr`. Затем сортировка этого массива пузырьком.

3. **Нахождение медианы всех элементов массива:**  
   Заполняем массив `med`  всеми элементами исходного массива, а затем сортируем его пузырьком по возрастанию. Потом в зависимости от количества
   элементов в исходного массиве выводим значение медианы

4. **Распределение чисел исходного массива по интервалам и нахождение количества элементов исходного массива в каждом из них:**  
   Задаем минимальное и максимальное значение общего интервала значений (`min` и `max`). Затем считаем количество элементов исходного массива
    в каждом интервале [n; n+10) и записываем в соответвующий элемент массива `gest`. Затем выводим в две строки интервал, а под ним количество
    элементов в данном интервале.


### 6. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    // Объявляем объект класса Scanner для ввода данных
    public static Scanner in = new Scanner(System.in);
    // Объявляем объект класса PrintStream для вывода данных
    public static PrintStream out = System.out;
    public static void main(String[] args) {


        //Ввод размеров массива
        out.print("Введите N и M: ");
        //Считываем число строк
        int N = in.nextInt();
        //Считываем число столбцов
        int M = in.nextInt();
        //Проверяем входные данные, если
        //ввели пустой массив сообщаем об этом и завершаем программу.
        if (N==0 || M==0){
            out.print("Вы ввели пустой массив");
            System.exit(0);
        }


        //создание вспомогательных переменных
        int ind;
        double sum = 0;
        int min;
        int max;
        double temp;
        double disp = 0;
        double min1;
        double max1;


        //создание основного и вспомогательных массивов
        double[][] a = new double[N][M];
        double[][] sorted = new double[N][M];
        double [] med = new double [N*M];
        double[][] sr = new double[3][M];


        //Ввод элементов массива
        out.println("Введите элементы массива: ");
        for (int i = 0; i < N; i++)
            for (int j = 0; j < M; j++)
                a[i][j] = in.nextDouble();


        //Заполнение вспомогательного массива данными о номере столбца и среднем арифметическом значении чисел в нем
        for (int j = 0; j < M; j++) {
            for (int i = 0; i < N; i++)
                //Считаем сумму элементов в столбце
                sum += a[i][j];
            //Записываем значение среднего арифметического в столбце
            sr[0][j] = sum / N;
            sr[2][j] = j;
            sum = 0;
        }


        //Добавление информации во вспомогательный массив о дисперсии в каждом столбце исходного массива
        for (int j = 0; j < M; j++) {
            for (int i = 0; i < N; i++)
                //Считаем дисперсию столбца
                disp += Math.pow(a[i][j] - sr[0][j], 2);
            //Записываем значение дисперсии в столбце
            sr[1][j] = disp / N;
            disp = 0;
        }


        //Сортировка массива sr по возрастанию значений в первой строке(средние арифметические столбцов исходного массива)
        //При их совпадении, сортировка по возрастанию значений во второй строке(дисперсия столбцов исходного массива)
        for (int i = 0; i < M - 1; i++) {
            for (int j = 0; j < M - 1 - i; j++) {
                //Если среднее арифметическое в одном столбце больше,
                // чем в другом, переставляем элементы массива местами
                if (sr[0][j] > sr[0][j + 1]) {
                    //Переставляем два элемента массива местами в первой строке
                    temp = sr[0][j];
                    sr[0][j] = sr[0][j + 1];
                    sr[0][j + 1] = temp;
                    //Переставляем два элемента массива местами во второй строке
                    temp = sr[1][j];
                    sr[1][j] = sr[1][j + 1];
                    sr[1][j + 1] = temp;
                    //Переставляем два элемента массива местами в третьей строке
                    temp = sr[2][j];
                    sr[2][j] = sr[2][j + 1];
                    sr[2][j + 1] = temp;
                }
                //Если среднее арифметическое в одном столбце равно среднему
                // арифметическому в другом и дисперсия в одном больше,
                // чем в другом, переставляем элементы массива местами
                if (sr[0][j] == sr[0][j + 1] && sr[1][j] > sr[1][j + 1]) {
                    //Переставляем два элемента массива местами в первой строке
                    temp = sr[0][j];
                    sr[0][j] = sr[0][j + 1];
                    sr[0][j + 1] = temp;
                    //Переставляем два элемента массива местами во второй строке
                    temp = sr[1][j];
                    sr[1][j] = sr[1][j + 1];
                    sr[1][j + 1] = temp;
                    //Переставляем два элемента массива местами в третьей строке
                    temp = sr[2][j];
                    sr[2][j] = sr[2][j + 1];
                    sr[2][j + 1] = temp;
                }
            }
        }


        //Сортировка столбцов введенного массива по возрастанию среднего арифметического значения в столбце.
        // Если средние значения совпадают, сортировка по возрастанию дисперсии элементов в столбце.
        // Выполняется на основе отсортированного вспомогательного массива
        for (int j = 0; j < M; j++) {
            ind = (int)sr[2][j];
            for (int i = 0; i < N; i++) {
                sorted[i][j] = a[i][ind];
            }
        }


        //Заполнения вспомогательного массива med всеми элементами
        //исходного массива для нахождения медианы
        for (int i = 0, inde=0; i < N; i++)
            for (int j = 0; j < M; j++) {
                med[inde] = sorted[i][j];
                inde++;
            }


        //Сортировка массива med по возрастанию элементов
        for (int i = N*M-1; i >=1; i--){
            for (int j = 0; j < i; j++){
                //Если один элемент массива больше другого,
                //меняем их местами
                if(med[j]>med[j+1]){
                    temp = med[j];
                    med[j] = med[j + 1];
                    med[j + 1] = temp;
                }
            }
        }


        //нахождение медианы элементов исходного массива на основе отсортированного массива med
        int help = N*M/2;
        //Если количество элементов в массиве нечетное, то выводим средний элемент
        if (N*M%2 != 0)
            out.print("Медиана последовательности = "+ med[help]);
        else
            //ЕСли четное, то выводим среднее арифметическое двух центральных элементов
            out.print("Медиана последовательности = "+ (med[help+1]+med[help])/2);
        out.println();

        //Минимальный элемент массива
        min1=med[0];
        //Максимальный элемент массива
        max1=med[N*M-1];
        //Нижняя граница общего интервала
        min=(int)med[0]/10-1;
        //Верхняя граница общего интервала
        max=(int)med[N*M-1]/10+1;
        int[] gist = new int [(int)(Math.abs(max1-min1)/10)+2];
        //Распределение чисел исходного массива по интервалам и нахождение количества элементов в каждом интервале
        for (int i = 0; i < gist.length; i++)
            gist[i]=0;
        for (int i = min,ind1 = 0; i < max; i++, ind1++){
            for (int j = 0; j < N*M; j++){
                //Подсчет количества элементов исходного массива в каждом интервале
                if (med[j] >= 10*i && med[j] < 10*(i+1))
                    gist[ind1] += 1;
            }
        }
        //Вывод данных гистрограммы. Сначала интервал, а под ним количество элементов в интервале
        for (int i = min; i < max; i++){
            out.print("от " + i*10 + " до " + (i+1)*10 + "  ");
        }
        out.println();
        for (int i = 0; i < gist.length; i++)
            out.format("%7d      ", gist[i]);


        //нормализация и вывод отсортированного исходного массива
        //Задаём нормализующий элемент в зависимости от максимального
        //элемента исходного массива
        for (int j = 0; j < M; j++)
            for (int i = 0; i < N; i++)
                //Приводим отсортированный исходный массив к
                //интервалу от 0 до 1
                sorted[i][j] = (sorted[i][j]-min1)/(max1-min1);
        out.println();
        out.println("Нормализованный массив:");
        //Выводим нормализованный массив
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                out.printf("%.3f", sorted[i][j]);
                out.print(" ");
            }
            out.println();
        }
    }
}
```

### 7. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на пустой массив:

    - **Input**:
        ```
        Введите N и M: 0 1
        ```

    - **Output**:
        ```
        Вы ввели пустой массив
        ```
        
    - **Input**:
        ```
        Введите N и M: 2 0
        ```

    - **Output**:
        ```
        Вы ввели пустой массив
        ```

2. Тест на массив с нечетным количеством элементов:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        1,2 2,3 3,4
        4,5 5,6 6,7
        7,8 8,9 9,1
        ```

    - **Output**:
        ```
        Медиана последовательности = 5.6
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,132 0,253 0,374 
        0,495 0,615 0,736 
        0,857 0,978 1,000 

        ```

3. Тест на массив с четным количеством элементов:

    - **Input**:
        ```
        Введите N и M: 2 2
        Введите элементы массива: 
        1,5 2,5
        3,5 4,5
        ```

    - **Output**:
        ```
        Медиана последовательности = 4.0
        от -10 до 0  от 0 до 10  
              0          4    
        Нормализованный массив:
        0,333 0,556 
        0,778 1,000 
        ```
4. Тест на массив с одинаковыми значениями среднего арифметического в двух столбцах:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        0,5 1,5 2,5
        3,5 4,5 5,5
        9,5 7,5 8,5

        ```

    - **Output**:
        ```
        Медиана последовательности = 4.5
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,158 0,053 0,263 
        0,474 0,368 0,579 
        0,789 1,000 0,895
        ```
5. Тест на массив с одинаковыми значениями среднего арифметического и дисперсии в двух столбцах:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        0,5 1,5 2,5
        2,5 1,5 0,5
        3,5 4,5 3,5
        ```

    - **Output**:
        ```
        Медиана последовательности = 2.5
        от -10 до 0  от 0 до 10  
              0          9    
        Нормализованный массив:
        0,111 0,556 0,333 
        0,556 0,111 0,333 
        0,778 0,778 1,000
        ```
6. Тест на массив с отрицательными числами:

    - **Input**:
        ```
        Введите N и M: 3 3
        Введите элементы массива: 
        -1,0 -2,0 -3,0
        4,0 5,0 6,0
        -11,0 12,0 15,0
        ```

    - **Output**:
        ```
        Медиана последовательности = 4.0
        от -20 до -10  от -10 до 0  от 0 до 10  от 10 до 20  
              1            3            3            2      
        Нормализованный массив:
        0,385 0,346 0,308 
        0,577 0,615 0,654 
        0,000 0,885 1,000 

        ```
